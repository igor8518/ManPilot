//------------------------------------------------------------------------------
//
//  PMDG 737NGX external connection sample 
// 
//------------------------------------------------------------------------------
/*#pragma once
#include "PMDG_NGX.h"
namespace PMDG_TEST{
	using namespace System::Threading;






	// this variable keeps the state of one of the NGX switches
	// NOTE - add these lines to <FSX>\PMDG\PMDG 737 NGX\737NGX_Options.ini: 
	//
	//[SDK]
	//EnableDataBroadcast=1
	//
	// to enable the data sending from the NGX.

	bool NGX_FuelPumpLAftLight = true;
	bool NGX_TaxiLightSwitch = false;
	bool NGX_LogoLightSwitch = false;
	double speed = 10;

	// This function is called when NGX data changes
	void ProcessNGXData(PMDG_NGX_Data *pS)
	{
		// test the data access:
		// get the state of an annunciator light and display it

		if (pS->FUEL_annunLOWPRESS_Aft[0] != NGX_FuelPumpLAftLight)
		{
			NGX_FuelPumpLAftLight = pS->FUEL_annunLOWPRESS_Aft[0];
			if (NGX_FuelPumpLAftLight)
				AddText("\nLOW PRESS LIGHT: [ON]\n");

			else
				AddText("\nLOW PRESS LIGHT: [OFF]\n");
		}

		// get the state of switches and save it for later use
		if (pS->LTS_TaxiSw != NGX_TaxiLightSwitch)
		{
			NGX_TaxiLightSwitch = pS->LTS_TaxiSw;
			if (NGX_TaxiLightSwitch)
				AddText("\nTAXI LIGHTS: [ON]\n");
			else
				AddText("\nTAXI LIGHTS: [OFF]\n");
		}

		if (pS->LTS_LogoSw != NGX_LogoLightSwitch)
		{
			NGX_LogoLightSwitch = pS->LTS_LogoSw;
			if (NGX_LogoLightSwitch)
				AddText("\nLOGO LIGHTS: [ON]\n");

			else
				AddText("\nLOGO LIGHTS: [OFF]\n");
		}
	}

	void toggleTaxiLightSwitch()
	{
		// Test the first control method: use the control data area.
		if (AircraftRunning)
		{
			bool New_TaxiLightSwitch = !NGX_TaxiLightSwitch;

			// Send a command only if there is no active command request and previous command has been processed by the NGX
			if (Control.Event == 0)
			{
				Control.Event = EVT_OH_LIGHTS_TAXI;		// = 69749
				if (New_TaxiLightSwitch)
					Control.Parameter = 1;
				else
					Control.Parameter = 0;

				SimConnect_SetClientData(hSimConnect, PMDG_NGX_CONTROL_ID, PMDG_NGX_CONTROL_DEFINITION,
					0, 0, sizeof(PMDG_NGX_Control), &Control);
			}
		}
	}

	void toggleLogoLightsSwitch()
	{
		// Test the second control method: send an event
		// use direct switch position
		bool New_LogoLightSwitch = !NGX_LogoLightSwitch;

		int parameter = 5000;
		//SimConnect_TransmitClientEvent(hSimConnect, 0, EVENT_THROTTLE_SET, parameter,
		//SIMCONNECT_GROUP_PRIORITY_HIGHEST, SIMCONNECT_EVENT_FLAG_GROUPID_IS_PRIORITY);
	}

	void toggleFlightDirector()
	{
		// Test the second control method: send an event
		// use mouse simulation to toggle the switch
		SimConnect_TransmitClientEvent(hSimConnect, 0, EVENT_FLIGHT_DIRECTOR_SWITCH, MOUSE_FLAG_LEFTSINGLE,
			SIMCONNECT_GROUP_PRIORITY_HIGHEST, SIMCONNECT_EVENT_FLAG_GROUPID_IS_PRIORITY);
		SimConnect_TransmitClientEvent(hSimConnect, 0, EVENT_FLIGHT_DIRECTOR_SWITCH, MOUSE_FLAG_LEFTRELEASE,
			SIMCONNECT_GROUP_PRIORITY_HIGHEST, SIMCONNECT_EVENT_FLAG_GROUPID_IS_PRIORITY);
	}

	void slewHeadingSelector()
	{
		// Test the second control method: send an event
		// use mouse simulation to slew a knob
		SimConnect_TransmitClientEvent(hSimConnect, 0, EVENT_HEADING_SELECTOR, MOUSE_FLAG_WHEEL_UP,
			SIMCONNECT_GROUP_PRIORITY_HIGHEST, SIMCONNECT_EVENT_FLAG_GROUPID_IS_PRIORITY);
	}

	void throttleSet(DWORD position)
	{
		SetPositionControl((INT16)(position));
	}

	void throttleLever(DWORD position)
	{

		throttle.L = position;
		throttle.R = position;
		SimConnect_SetDataOnSimObject(hSimConnect, DEF_THROTTLE, 0, 0, 0, sizeof(tthrottle), &throttle);
	}
	void setThrust(FLOAT thrust)
	{
		static clock_t startTime;
		static double throttle = 0;
		static double startThrust = PMDG_TEST::thrust.N1L;
		clock_t endTime = clock() + 1;
		double endThrust = PMDG_TEST::thrust.N1L;
		double timeOff = endTime - startTime;
		double thrustOff = endThrust - startThrust;
		double thrustA = (timeOff / 1000)*thrustOff;

		double dT = thrust - endThrust;
		double dA = (dT / 5) - thrustA;
		double dThrottle = dA;
		if (dThrottle < -5)
		{
			dThrottle = -5;
		}
		else if (dThrottle > 5)
		{
			dThrottle = 5;
		}
		throttle = throttle + dThrottle;
		bool thrustSet = FALSE;
		//int throttle = (int)((thrust - 21) / (100 - 21) * 90);
		if (throttle < 0)
		{
			throttle = 0;
		}
		else if (throttle > 100)
		{
			throttle = 100;
		}
		throttleLever(throttle);
		thrustSet = TRUE;
		startTime = clock();
		startThrust = PMDG_TEST::thrust.N1L;
	}

	void setGSpeed(FLOAT speed, FLOAT Tr = 0)
	{
		static clock_t startTime;
		static double thrust = PMDG_TEST::thrust.N1L;
		static double throttle = 0;
		static double startSpeed = PMDG_TEST::speeds.GS;
		clock_t endTime = clock() + 1;
		double endSpeed = PMDG_TEST::speeds.GS;
		double timeOff = endTime - startTime;
		double speedOff = endSpeed - startSpeed;
		double speedA = (timeOff / 1000)*speedOff;

		double dS = speed - endSpeed;
		double dA = (dS / 5) - speedA;

		double dThrust = dA;
		if (dThrust < -5)
		{
			dThrust = -5;
		}
		else if (dThrust > 5)
		{
			dThrust = 5;
		}
		if ((speedA < -0.3) && (speedA > -0.4))
		{
			dThrust = dThrust + 2;
		}
		else if ((speedA > 0.3) && (speedA < 0.4))
		{
			dThrust = dThrust - 2;
		}
		if (speedA < -0.4)
		{
			dThrust = dThrust + 5;
		}
		else if (speedA >= 0.4)
		{
			dThrust = dThrust - 5;
		}
		thrust = PMDG_TEST::thrust.N1L + dThrust;

		bool thrustSet = FALSE;
		if (thrust < 21)
		{
			thrust = 21;
		}
		else if (thrust > 100)
		{
			thrust = 100;
		}
		setThrust(thrust);


		thrustSet = TRUE;
		startTime = clock();
		startSpeed = PMDG_TEST::speeds.GS;
	}

	void CALLBACK MyDispatchProc(SIMCONNECT_RECV* pData, DWORD cbData, void *pContext)
	{
		switch (pData->dwID)
		{
		case SIMCONNECT_RECV_ID_CLIENT_DATA: // Receive and process the NGX data block
		{
												 SIMCONNECT_RECV_CLIENT_DATA *pObjData = (SIMCONNECT_RECV_CLIENT_DATA*)pData;

												 switch (pObjData->dwRequestID)
												 {
												 case DATA_REQUEST:
												 {
																	  PMDG_NGX_Data* ps = (PMDG_NGX_Data*)&pObjData->dwData;
																	  NGX = *(PMDG_NGX_Data*)&pObjData->dwData;
																	  //ProcessNGXData(&NGX);
																	  GetNGXData = TRUE;
																	  SIMCONNECT_RECV_EVENT *pObjData = (SIMCONNECT_RECV_EVENT*)pData;
																	  switch (pObjData->uEventID)
																	  {
																	  case(0) :
																	  {
																				  break;
																	  }
																	  default:
																	  {
																				 AddText("Data: " + pObjData->uEventID + "\n");
																				 break;
																	  }
																	  }
																	  break;
												 }
												 case CONTROL_REQUEST:
												 {
																		 // keep the present state of Control area to know if the server had received and reset the command
																		 PMDG_NGX_Control *pS = (PMDG_NGX_Control*)&pObjData->dwData;
																		 Control = *pS;
																		 break;
												 }
												 case ADD_DATA_REQUEST:
												 {
																		  sExportData *pS = (sExportData*)&pObjData->dwData;
																		  ExportData.HorBar = pS->HorBar;
																		  ExportData.HorEnabled = pS->HorEnabled;
																		  ExportData.VerBar = pS->VerBar;
																		  ExportData.VerEnabled = pS->VerEnabled;
																		  //PData = ps;
																		  break;
												 }
												 default:
												 {
															AddText("NON Data request and not control request");
															break;
												 }
												 }
												 break;
		}
		case SIMCONNECT_RECV_ID_SIMOBJECT_DATA:
		{
												  SIMCONNECT_RECV_SIMOBJECT_DATA *pObjData = (SIMCONNECT_RECV_SIMOBJECT_DATA*)pData;
												  switch (pObjData->dwRequestID)
												  {
												  case REQ_AIRCRAFT_USER:
												  {
																			DWORD ObjectID = pObjData->dwObjectID;
																			aircraftData *ps = (aircraftData*)&pObjData->dwData;
																			PMDG_TEST::AircraftData = *((aircraftData*)&pObjData->dwData);
																			PMDG_TEST::AircraftData.ailer = PMDG_TEST::AircraftData.ailer*4.16666666666666667;
																			//AddText("CLIMB: " + "CLIMB" + "\n");

																			break;
												  }
												  case REQ_THRUST:
												  {
																	 PMDG_TEST::thrust = *(tthrust*)&pObjData->dwData;
																	 //setThrust(80);
																	 break;
												  }
												  case REQ_SPEEDS:
												  {
																	 PMDG_TEST::speeds = *(tspeeds*)&pObjData->dwData;
																	 tspeeds *ps = (tspeeds*)&pObjData->dwData;
																	 if (ps->simOnGround == 1)
																	 {
																		 if (mode == TAXI_OUT)
																		 {
																			 setGSpeed(speed);
																		 }
																		 //else if ((mode == TAKE_OFF)&&(ps->TOGA == 0))
																		 //{
																		 //	 throttleLever(24);
																		 // }
																	 }
																	 break;
												  }

												  default:
												  {
															 break;
												  }
												  }
												  break;

		}

		case SIMCONNECT_RECV_ID_EVENT:
		{
										 SIMCONNECT_RECV_EVENT *evt = (SIMCONNECT_RECV_EVENT*)pData;

										 switch (evt->uEventID)
										 {
										 case EVENT_ELEVATOR_SET:
										 {
																	SetDataPitch = true;
																	break;
										 }
										 case EVENT_SIM_START:	// Track aircraft changes
										 {
																	HRESULT hr = SimConnect_RequestSystemState(hSimConnect, AIR_PATH_REQUEST, "AircraftLoaded");
																	break;
										 }
										 case EVENT_KEYBOARD_A:
										 {
																  toggleTaxiLightSwitch();
																  quit = 1;
																  break;
										 }
										 case EVENT_KEYBOARD_B:
										 {
																  toggleLogoLightsSwitch();
																  break;
										 }
										 case EVENT_KEYBOARD_C:
										 {
																  toggleFlightDirector();
																  break;
										 }
										 case EVENT_KEYBOARD_D:
										 {
																  slewHeadingSelector();
																  break;
										 }
										 case EVENT_THROTTLE_SET:
										 {
																	AddText("Value: " + (INT16)evt->dwData + "\n");
																	//throttleSet(evt->dwData);
																	break;
										 }
										 case EVENT_TEXT:
										 {
															//AddText("Value: " + (INT16)evt->dwData + "\n");
															//throttleSet(evt->dwData);
															break;
										 }
										 default:
										 {
													AddText("EVENT\n");
													break;
										 }
										 }
										 break;

		}

		case SIMCONNECT_RECV_ID_SYSTEM_STATE: // Track aircraft changes
		{
												  SIMCONNECT_RECV_SYSTEM_STATE *evt = (SIMCONNECT_RECV_SYSTEM_STATE*)pData;
												  if (evt->dwRequestID == AIR_PATH_REQUEST)
												  {
													  if (strstr(evt->szString, "PMDG 737") != NULL)
													  {
														  AircraftRunning = true;
														  AddText("Select B737\n");
													  }
													  else
													  {
														  AircraftRunning = false;
														  AddText("Select: " + (gcnew System::String(evt->szString)) + "\n");
													  }
												  }
												  else
												  {
													  AddText(String::Format("SIMCONNECT_RECV_SYSTEM_STATE: {0}\n", evt->dwRequestID));
												  }
												  break;
		}

		case SIMCONNECT_RECV_ID_QUIT:
		{
										quit = 1;
										break;
		}

		case SIMCONNECT_RECV_ID_EXCEPTION:
		{
											 SIMCONNECT_RECV_EXCEPTION *evt = (SIMCONNECT_RECV_EXCEPTION*)pData;
											 //quit = 1;
											 break;
		}

		default:
		{
				   AddText(String::Format("Received: {0}\n", pData->dwID));
				   break;
		}
		}
	}

	void loopThrFunc()
	{
		int ii = 0; //Убрать
		while (quit == 0)
		{
			hr = SimConnect_RequestDataOnSimObject(hSimConnect, REQ_AIRCRAFT_USER, DEF_AIRCRAFT_USER, SIMCONNECT_OBJECT_ID_USER, SIMCONNECT_PERIOD_ONCE);
			SimConnect_CallDispatch(hSimConnect, MyDispatchProc, NULL);
			aircraftData* PaircraftData = &AircraftData;
			switch (mode)
			{
			case PREPARE:
			{
							AddText("MODE: PREPARE" + "\n", true);

							SimConnect_TransmitClientEvent(hSimConnect, 0, EVENT_CONTROL_STAND_FLAPS_LEVER_5, MOUSE_FLAG_LEFTSINGLE, SIMCONNECT_GROUP_PRIORITY_HIGHEST, SIMCONNECT_EVENT_FLAG_GROUPID_IS_PRIORITY);
							if (GetNGXData)
							{
								setNGXDataBool(EVT_MCP_FD_SWITCH_L, TRUE, &NGX.MCP_FDSw[0]);
								setNGXDataBool(EVT_MCP_FD_SWITCH_R, TRUE, &NGX.MCP_FDSw[1]);
								setNGXDataBool(EVT_MCP_AT_ARM_SWITCH, TRUE, &NGX.MCP_annunATArm);
								setNGXDataFloat(EVT_MCP_SPEED_SELECTOR, 161, &NGX.MCP_IASMach);
								setNGXDataUShort(EVT_MCP_HEADING_SELECTOR, 80, &NGX.MCP_Heading);
								setNGXDataUShort(EVT_MCP_ALTITUDE_SELECTOR, CruiseLevel, &NGX.MCP_Altitude);
								setNGXDataDouble(EVT_CONTROL_STAND_TRIM_WHEEL, 6.44 - 3.9, &AircraftData.elevTrim);
								setNGXDataDouble(EVT_EFIS_CPT_BARO, 0, &AircraftData.alt, 11, -6, TRUE);
								setNGXDataBool(EVT_OH_LIGHTS_LOGO, TRUE, &NGX.LTS_LogoSw);
								setNGXDataBool(EVT_OH_LIGHTS_TAXI, TRUE, &NGX.LTS_TaxiSw);
								setNGXDataBool(EVT_OH_LIGHTS_ANT_COL, TRUE, &NGX.LTS_AntiCollisionSw);
								setNGXDataBool(EVT_OH_LIGHTS_L_TURNOFF, TRUE, &NGX.LTS_RunwayTurnoffSw[0]);
								setNGXDataBool(EVT_OH_LIGHTS_R_TURNOFF, TRUE, &NGX.LTS_RunwayTurnoffSw[1]);
								setNGXDataUChar(EVT_OH_LIGHTS_POS_STROBE, 0, &NGX.LTS_PositionSw, TRUE);
								setNGXDataUChar(EVT_OH_LIGHTS_L_RETRACT, 0, &NGX.LTS_LandingLtRetractableSw[0]);
								setNGXDataUChar(EVT_OH_LIGHTS_R_RETRACT, 0, &NGX.LTS_LandingLtRetractableSw[1]);
								setNGXDataBool(EVT_OH_LIGHTS_L_FIXED, FALSE, &NGX.LTS_LandingLtFixedSw[0]);
								setNGXDataBool(EVT_OH_LIGHTS_R_FIXED, FALSE, &NGX.LTS_LandingLtFixedSw[1]);
								mode = START;
							}

							break;
			}
			case START:
			{
						  AddText("MODE: " + "START" + "\n", true);
						  mode = TAXI_OUT;
						  break;
			}
			case TAXI_OUT:
			{
							 aircraftData* PaircraftData = &AircraftData;
							 //AddText("MODE: " + "TAXI_OUT"+"\n",true);
							 hr = SimConnect_RequestDataOnSimObject(hSimConnect, REQ_AIRCRAFT_USER, DEF_AIRCRAFT_USER, SIMCONNECT_OBJECT_ID_USER, SIMCONNECT_PERIOD_ONCE);
							 //Время для расчета ускорений
							 static clock_t sTime = 0; //Начальное время
							 clock_t eTime = clock();
							 //Начальное направление
							 static double sHed;
							 //Начальная скорость
							 static double sSpeed;

							 if (SUCCEEDED(StringCbLengthA(&PaircraftData->title[0], sizeof(PaircraftData->title), NULL)))
							 {
								 AddText("" + (gcnew System::String(PaircraftData->title)) + "\n");
							 }
							 //Конечное направление
							 double eHed = PaircraftData->hed;
							 //Конечная скорость
							 double eSpeed = PaircraftData->GS;
							 //Если первый вызов функции, то пропускаем расчет велечин, и устанавливаем начальные значения
							 if ((sTime != 0) && (PaircraftData->simOnGround == 1))
							 {
								 //Поперечное ускорение
								 double aHed = (eHed - sHed) / (double)((double)(eTime - sTime) / 1000);
								 //Продольное ускорение
								 double aSpeed = (eSpeed - sSpeed) / (double)((double)(eTime - sTime) / 1000);
								 AddText("rTime: " + (eTime - sTime) + "\n");
								 AddText("aHed: " + PaircraftData->aHed + "\n");
								 AddText("aSpeed: " + aSpeed + "\n");

								 //Расчет угла отклонения (EangleRel) в точке прибытия от заданного
								 AddText("CurrentWay: " + CurrentWay + "\n");
								 CurrentPos = *Ways[CurrentWay];
								 CurrentPos.Slla.Latitude = PaircraftData->lat;
								 CurrentPos.Slla.Longitude = PaircraftData->lon;
								 DOrtoKM(&CurrentPos);
								 int icw = CurrentWay;
								 double DCommon = CurrentPos.D;
								 while ((Ways[icw]->typePath != RUNWAY) && (icw<(CountWays - 1)))
								 {
									 DCommon += Ways[icw + 1]->D;
									 icw++;
								 }
								 CHAR s[256];
								 sprintf(s, "MODE: TAXI_OUT Current: %.3f km Total: %.3f km \n Current way: %d Type: %d Total ways: %d", CurrentPos.D, DCommon, CurrentWay, CurrentPos.typePath, CountWays);
								 AddText(gcnew String(s), true);
								 double EangleRel = CurrentPos.EH - Ways[CurrentWay]->EH;
								 if (EangleRel > 180)
								 {
									 EangleRel = EangleRel - 360;
								 }
								 else if (EangleRel < -180)
								 {
									 EangleRel = EangleRel + 360;
								 }
								 ////////////////////////////////////////////////////////

								 //Снижение скорости при расстоянии до поворота 500 м.
								 if (CurrentPos.D < 0.5)
								 {
									 speed = 10;
								 }
								 ////////////////////////////////////////////////////////

								 //Расчет начала поворота () в зависимости от скорости и разницы углов текущего и следующего путей
								 double REangle = 0.045;
								 if ((CurrentWay + 1) >= CountWays)
								 {
									 REangle = (Ways[0]->SH - Ways[CurrentWay]->EH);
								 }
								 else
								 {
									 REangle = Ways[CurrentWay + 1]->SH - Ways[CurrentWay]->EH;
								 }
								 if (REangle > 180)
								 {
									 REangle = REangle - 360;
								 }
								 else if (REangle < -180)
								 {
									 REangle = REangle + 360;
								 }
								 REangle = REangle * 5 * PMDG_TEST::speeds.GS / 100000;
								 ////////////////////////////////////////////////////////

								 //Проверка условия если угол отклонения больше 60 градусов, либо пройдена точка поворота,
								 // то ориентируемся на следующий путь. 
								 if ((EangleRel > 60) || (EangleRel < -60) || (CurrentPos.D < REangle))
								 {
									 CurrentWay = CurrentWay + 1;
									 /* if ((CurrentWay + 1) > CountSWays)
									 {
									 //CurrentWay = 0;
									 }/

								 }
								 //Иначе продолжаем удерживать текущий путь.
								 else
								 {
									 //Расчет расстояния (a) до текущего пути
									 double a = sin(EangleRel*M_PI / 180)* CurrentPos.D;
									 if ((EangleRel < 0) && (a > 0))
									 {
										 a = -a;
									 }
									 if ((EangleRel > 0) && (a < 0))
									 {
										 a = -a;
									 }
									 ////////////////////////////////////////////////////////

									 //Расчет угла поправки в зависимости от ошибки пути, но не больше 60 градусов для EangleRel и
									 //общего для EangleRel1
									 //Вариант 1
									 //EangleRel = (60 * a) / 0.07;
									 //Вариант 2
									 EangleRel = a * 1000;
									 double EangleRel1 = EangleRel;
									 if (EangleRel > 60)
									 {
										 EangleRel = 60;
									 }
									 else if (EangleRel < -60)
									 {
										 EangleRel = -60;
									 }
									 ////////////////////////////////////////////////////////

									 //Расчет необходимого угла для поправки ошибки пути
									 EangleRel = Ways[CurrentWay]->EH + EangleRel;
									 if (EangleRel > 180)
									 {
										 EangleRel = EangleRel - 360;
									 }
									 else if (EangleRel < -180)
									 {
										 EangleRel = EangleRel + 360;
									 }
									 ////////////////////////////////////////////////////////

									 //Расчет доворота (HeadingRel) до угла поправки ошибки (EangleRel)
									 double HeadingRel = EangleRel - PaircraftData->hed;
									 if (HeadingRel > 180)
									 {
										 HeadingRel = HeadingRel - 360;
									 }
									 else if (HeadingRel < -180)
									 {
										 HeadingRel = HeadingRel + 360;
									 }
									 AddText("HeadingRel: " + HeadingRel + "\n");
									 ////////////////////////////////////////////////////////
									 if ((((CurrentWay + 2) == CountWays) || (Ways[CurrentWay]->typePath == RUNWAY)) && (CurrentPos.D < 0.1))
									 {
										 setNGXDataBool(EVT_OH_LIGHTS_LOGO, TRUE, &NGX.LTS_LogoSw);
										 setNGXDataBool(EVT_OH_LIGHTS_TAXI, TRUE, &NGX.LTS_TaxiSw);
										 setNGXDataBool(EVT_OH_LIGHTS_ANT_COL, TRUE, &NGX.LTS_AntiCollisionSw);
										 setNGXDataBool(EVT_OH_LIGHTS_L_TURNOFF, TRUE, &NGX.LTS_RunwayTurnoffSw[0]);
										 setNGXDataBool(EVT_OH_LIGHTS_R_TURNOFF, TRUE, &NGX.LTS_RunwayTurnoffSw[1]);
										 setNGXDataUChar(EVT_OH_LIGHTS_POS_STROBE, 2, &NGX.LTS_PositionSw, TRUE);
										 setNGXDataUChar(EVT_OH_LIGHTS_L_RETRACT, 0, &NGX.LTS_LandingLtRetractableSw[0]);
										 setNGXDataUChar(EVT_OH_LIGHTS_R_RETRACT, 0, &NGX.LTS_LandingLtRetractableSw[1]);
										 setNGXDataBool(EVT_OH_LIGHTS_L_FIXED, TRUE, &NGX.LTS_LandingLtFixedSw[0]);
										 setNGXDataBool(EVT_OH_LIGHTS_R_FIXED, TRUE, &NGX.LTS_LandingLtFixedSw[1]);
									 }
									 // Если угол доворота (HeadingRel) и угол поправки (EangleRel1) меньше 5 градусов и расстояние до конечной точки 
									 // больше 500 метров, то увеличиваем скорость
									 if ((HeadingRel < 5) && (EangleRel1 < 5) && (HeadingRel > -5) && (EangleRel1 > -5) && (CurrentPos.D>0.5))
									 {
										 if (((CurrentWay + 1) == CountWays) || ((Ways[CurrentWay]->typePath == RUNWAY)))
										 {

											 speed = 0;
											 if (PaircraftData->GS < 1)
											 {
												 setThrust(40);
												 mode = TAKE_OFF;
											 }
										 }
										 else
										 {
											 speed = 20;
										 }
									 }
									 // иначе уменьшаем
									 else
									 {
										 speed = 10;
									 }
									 ////////////////////////////////////////////////////////

									 //Расчет необходимой угловой скорости для преодоления угла поворота																		
									 double parameter = HeadingRel / 4;
									 ////////////////////////////////////////////////////////
									 AddText("parameter: " + parameter + "\n");
									 //Расчет необходимого угла поворота стойки для удержания ускорения
									 double rud = PaircraftData->rud * 16383;
									 AddText("rud: " + rud + "\n");
									 //if (parameter < PaircraftData->aHed)
									 //{
									 //	rud = rud + (500 * (PaircraftData->aHed - parameter));
									 //}
									 //else if (parameter > PaircraftData->aHed)
									 //{
									 //	rud = rud - (500 * (parameter -PaircraftData->aHed));
									 //}
									 if (PaircraftData->GS > 15)
									 {

										 rud = rud - (50 * (PaircraftData->aHed - parameter)*(PaircraftData->GS) / 10);
									 }
									 else
									 {
										 rud = rud - (50 * (PaircraftData->aHed - parameter));
									 }
									 if (rud > 16383)
									 {
										 rud = 16383;
									 }
									 else if (rud < -16383)
									 {
										 rud = -16383;
									 }
									 //Инвертирование знака
									 int intParameter = -rud;
									 AddText("intParameter: " + intParameter + "\n");
									 ////////////////////////////////////////////////////////

									 //Отправка сообщения в сим
									 SimConnect_TransmitClientEvent(hSimConnect, 0, EVENT_RUDDER_SET, intParameter, \
										 SIMCONNECT_GROUP_PRIORITY_HIGHEST, SIMCONNECT_EVENT_FLAG_GROUPID_IS_PRIORITY);
								 }
							 }
							 else
							 {
								 SimConnect_TransmitClientEvent(hSimConnect, 0, EVENT_RUDDER_SET, 0, \
									 SIMCONNECT_GROUP_PRIORITY_HIGHEST, SIMCONNECT_EVENT_FLAG_GROUPID_IS_PRIORITY);

							 }
							 ////////////////////////////////////////////////////////
							 sTime = clock();
							 sHed = PaircraftData->hed;
							 sSpeed = PaircraftData->GS;
							 Sleep(50);
							 break;
			}
			case TAKE_OFF:
			{
							 static int StartThrottle = 0;
							 AddText("MODE: " + "TAKE_OFF" + "\n", true);
							 aircraftData* PaircraftData = &AircraftData;
							 hr = SimConnect_RequestDataOnSimObject(hSimConnect, REQ_AIRCRAFT_USER, DEF_AIRCRAFT_USER, SIMCONNECT_OBJECT_ID_USER, SIMCONNECT_PERIOD_ONCE);
							 //Время для расчета ускорений
							 static clock_t sTime = 0; //Начальное время
							 clock_t eTime = clock();
							 //Начальное направление
							 static double sHed;
							 //Начальная скорость
							 static double sSpeed;

							 //Конечное направление
							 double eHed = PaircraftData->hed;
							 //Конечная скорость
							 double eSpeed = PaircraftData->GS;
							 double NPitch = 0;
							 if (ExportData.HorEnabled == 1)
							 {
								 NPitch = -ExportData.HorBar;
							 }
							 else
							 {
								 NPitch = -15;
							 }
							 //Если первый вызов функции, то пропускаем расчет велечин, и устанавливаем начальные значения
							 setNGXDataBool(EVT_OH_LIGHTS_LOGO, TRUE, &NGX.LTS_LogoSw);
							 setNGXDataBool(EVT_OH_LIGHTS_TAXI, TRUE, &NGX.LTS_TaxiSw);
							 setNGXDataBool(EVT_OH_LIGHTS_ANT_COL, TRUE, &NGX.LTS_AntiCollisionSw);
							 setNGXDataBool(EVT_OH_LIGHTS_L_TURNOFF, TRUE, &NGX.LTS_RunwayTurnoffSw[0]);
							 setNGXDataBool(EVT_OH_LIGHTS_R_TURNOFF, TRUE, &NGX.LTS_RunwayTurnoffSw[1]);
							 setNGXDataUChar(EVT_OH_LIGHTS_POS_STROBE, 2, &NGX.LTS_PositionSw, TRUE);
							 setNGXDataUChar(EVT_OH_LIGHTS_L_RETRACT, 2, &NGX.LTS_LandingLtRetractableSw[0]);
							 setNGXDataUChar(EVT_OH_LIGHTS_R_RETRACT, 2, &NGX.LTS_LandingLtRetractableSw[1]);
							 setNGXDataBool(EVT_OH_LIGHTS_L_FIXED, TRUE, &NGX.LTS_LandingLtFixedSw[0]);
							 setNGXDataBool(EVT_OH_LIGHTS_R_FIXED, TRUE, &NGX.LTS_LandingLtFixedSw[1]);
							 //Разгон двигателей и включение режима TO/GA
							 if (PaircraftData->N1L > 40)
							 {
								 if (!TOGA)
								 {

									 SimConnect_TransmitClientEvent(hSimConnect, 0, EVENT_TOGA, 1, \
										 SIMCONNECT_GROUP_PRIORITY_HIGHEST, SIMCONNECT_EVENT_FLAG_GROUPID_IS_PRIORITY);
									 TOGA = TRUE;
								 }
							 }
							 else
							 {
								 throttleLever(StartThrottle);
								 if (SetTimeOff(TAKE_OFF, 3000))
								 {
									 StartThrottle = StartThrottle + 4;
								 }
							 }
							 //////////////////////////////////////////////////////
							 //При V=230 шасси нейтрально
							 if (PaircraftData->AS > 230)
							 {
								 setNGXDataUChar(EVT_GEAR_LEVER, 1, &NGX.MAIN_GearLever);
							 }
							 ////////////////////////////////
							 //При 220<V<230 Убираем закрылки и включаем SPEED либо LVL_CHG
							 else if (PaircraftData->AS > 220)
							 {

								 SimConnect_TransmitClientEvent(hSimConnect, 0, EVENT_CONTROL_STAND_FLAPS_LEVER_0, MOUSE_FLAG_LEFTSINGLE, SIMCONNECT_GROUP_PRIORITY_HIGHEST, SIMCONNECT_EVENT_FLAG_GROUPID_IS_PRIORITY);

								 //setNGXDataFloat(EVT_MCP_SPEED_SELECTOR, 240, &NGX.MCP_IASMach);

								 if (NGX.MCP_Altitude > 5000)
								 {
									 //setNGXDataBool(EVT_MCP_LVL_CHG_SWITCH, TRUE, &NGX.MCP_annunLVL_CHG);
								 }
								 else
								 {
									 //setNGXDataBool(EVT_MCP_SPEED_SWITCH, TRUE, &NGX.MCP_annunSPEED);
								 }
								 if (ExportData.HorEnabled == 1)
								 {
									 NPitch = -ExportData.HorBar;
								 }
								 else
								 {
									 NPitch = -15;
								 }
							 }
							 //////////////////////////////////////
							 //При 190<V<220 закрылки 1
							 else if (PaircraftData->AS > 190)
							 {
								 SimConnect_TransmitClientEvent(hSimConnect, 0, EVENT_CONTROL_STAND_FLAPS_LEVER_1, MOUSE_FLAG_LEFTSINGLE, SIMCONNECT_GROUP_PRIORITY_HIGHEST, SIMCONNECT_EVENT_FLAG_GROUPID_IS_PRIORITY);
								 if (ExportData.HorEnabled == 1)
								 {
									 NPitch = -ExportData.HorBar;
								 }
								 else
								 {
									 NPitch = -15;
								 }
							 }
							 //При V<190 и самолет в воздухе триммируем его
							 if ((PaircraftData->AS < 190) && (PaircraftData->simOnGround == FALSE))
							 {
								 if (ExportData.HorEnabled == 1)
								 {
									 NPitch = -ExportData.HorBar;
								 }
								 else
								 {
									 NPitch = -15;
								 }

							 }
							 //Мы готовы к отрыву
							 if (PaircraftData->AS > 150)
							 {
								 //При положительном наборе убираем шасси и включаем режим N1
								 if ((PaircraftData->VS > 30) && (PaircraftData->simOnGround == FALSE))
								 {
									 setNGXDataUChar(EVT_GEAR_LEVER, 0, &NGX.MAIN_GearLever);
									 //setNGXDataFloat(EVT_MCP_SPEED_SELECTOR, 220, &NGX.MCP_IASMach);
									 //setNGXDataBool(EVT_MCP_N1_SWITCH, TRUE, &NGX.MCP_annunN1);
									 //setNGXDataBool(EVT_MCP_LVL_CHG_SWITCH, TRUE, &NGX.MCP_annunLVL_CHG);
								 }
								 //При высоте больше 1800 включаем автопилот и переходим в режим набора высоты
								 if (PaircraftData->alt > 1800)
								 {
									 SimConnect_TransmitClientEvent(hSimConnect, 0, EVENT_ELEVATOR_SET, 0, \
										 SIMCONNECT_GROUP_PRIORITY_HIGHEST, SIMCONNECT_EVENT_FLAG_GROUPID_IS_PRIORITY);
									 //setNGXDataFloat(EVT_MCP_SPEED_SELECTOR, NGX.MCP_IASMach + 20, &NGX.MCP_IASMach);
									 if (NGX.MCP_Altitude > 5000)
									 {
										 //setNGXDataBool(EVT_MCP_LVL_CHG_SWITCH, TRUE, &NGX.MCP_annunLVL_CHG);
									 }
									 //setNGXDataBool(EVT_MCP_HDG_SEL_SWITCH, TRUE, &NGX.MCP_annunHDG_SEL);
									 //setNGXDataBool(EVT_MCP_CMD_A_SWITCH, TRUE, &NGX.MCP_annunCMD_A);
									 if (NGX.MCP_Altitude > 5000)
									 {
										 //setNGXDataBool(EVT_MCP_LVL_CHG_SWITCH, TRUE, &NGX.MCP_annunLVL_CHG);
									 }
									 else
									 {
										 //setNGXDataBool(EVT_MCP_SPEED_SWITCH, TRUE, &NGX.MCP_annunSPEED);
									 }
									 TOGA = FALSE;
									 mode = CLIMB;
								 }
								 //Если режим LVL_CHG не включен триммируем самолет в ручную
								 if (!NGX.MCP_annunCMD_A)
								 {

									 ManPitchWithFD(NPitch, PaircraftData);

									 if (ExportData.VerEnabled == 1)
									 {
										 ManBankWithFD(-ExportData.VerBar, PaircraftData);
									 }
									 else
									 {
										 ManBankWithFD(0, PaircraftData);
									 }


								 }
							 }
							 //////////////////////////
							 //При 140<V<150 подготавливаем руль высоты
							 else if ((PaircraftData->AS > 140) && (PaircraftData->AS < 150))
							 {
								 SimConnect_TransmitClientEvent(hSimConnect, 0, EVENT_ELEVATOR_SET, -5000, \
									 SIMCONNECT_GROUP_PRIORITY_HIGHEST, SIMCONNECT_EVENT_FLAG_GROUPID_IS_PRIORITY);
							 }
							 //Удерживаем курс рулем направления пока на земле
							 if ((sTime != 0) && (PaircraftData->simOnGround == 1))
							 {
								 //Поперечное ускорение
								 double aHed = (eHed - sHed) / (double)((double)(eTime - sTime) / 1000);
								 //Продольное ускорение
								 double aSpeed = (eSpeed - sSpeed) / (double)((double)(eTime - sTime) / 1000);
								 AddText("rTime: " + (eTime - sTime) + "\n");
								 AddText("aHed: " + PaircraftData->aHed + "\n");
								 AddText("aSpeed: " + aSpeed + "\n");

								 //Расчет угла отклонения (EangleRel) в точке прибытия от заданного
								 CurrentPos = *Ways[CurrentWay];
								 CurrentPos.Slla.Latitude = PaircraftData->lat;
								 CurrentPos.Slla.Longitude = PaircraftData->lon;
								 DOrtoKM(&CurrentPos);
								 double EangleRel = CurrentPos.EH - Ways[CurrentWay]->EH;
								 if (EangleRel > 180)
								 {
									 EangleRel = EangleRel - 360;
								 }
								 else if (EangleRel < -180)
								 {
									 EangleRel = EangleRel + 360;
								 }
								 ////////////////////////////////////////////////////////

								 //Расчет расстояния (a) до текущего пути
								 double a = sin(EangleRel*M_PI / 180)* CurrentPos.D;
								 if ((EangleRel < 0) && (a > 0))
								 {
									 a = -a;
								 }
								 if ((EangleRel > 0) && (a < 0))
								 {
									 a = -a;
								 }
								 ////////////////////////////////////////////////////////

								 //Расчет угла поправки в зависимости от ошибки пути, но не больше 60 градусов для EangleRel и
								 //общего для EangleRel1
								 //Вариант 1
								 //EangleRel = (60 * a) / 0.07;
								 //Вариант 2
								 EangleRel = a * 1000;
								 double EangleRel1 = EangleRel;
								 if (EangleRel > 60)
								 {
									 EangleRel = 60;
								 }
								 else if (EangleRel < -60)
								 {
									 EangleRel = -60;
								 }
								 ////////////////////////////////////////////////////////

								 //Расчет необходимого угла для поправки ошибки пути
								 EangleRel = Ways[CurrentWay]->EH + EangleRel;
								 if (EangleRel > 180)
								 {
									 EangleRel = EangleRel - 360;
								 }
								 else if (EangleRel < -180)
								 {
									 EangleRel = EangleRel + 360;
								 }
								 ////////////////////////////////////////////////////////

								 //Расчет доворота (HeadingRel) до угла поправки ошибки (EangleRel)
								 double HeadingRel = EangleRel - PaircraftData->hed;
								 if (HeadingRel > 180)
								 {
									 HeadingRel = HeadingRel - 360;
								 }
								 else if (HeadingRel < -180)
								 {
									 HeadingRel = HeadingRel + 360;
								 }
								 AddText("HeadingRel: " + HeadingRel + "\n");
								 ////////////////////////////////////////////////////////

								 //Расчет необходимой угловой скорости для преодоления угла поворота																		
								 double parameter = HeadingRel / 4;
								 ////////////////////////////////////////////////////////
								 AddText("parameter: " + parameter + "\n");
								 //Расчет необходимого угла поворота стойки для удержания ускорения
								 double rud = PaircraftData->rud * 16383;
								 AddText("rud: " + rud + "\n");

								 if (PaircraftData->GS > 15)
								 {

									 rud = rud - (50 * (PaircraftData->aHed - parameter)*(PaircraftData->GS) / 10);
								 }
								 else
								 {
									 rud = rud - (50 * (PaircraftData->aHed - parameter));
								 }
								 if (rud > 16383)
								 {
									 rud = 16383;
								 }
								 else if (rud < -16383)
								 {
									 rud = -16383;
								 }
								 //Инвертирование знака
								 int intParameter = -rud;
								 AddText("intParameter: " + intParameter + "\n");
								 ////////////////////////////////////////////////////////

								 //Отправка сообщения в сим
								 SimConnect_TransmitClientEvent(hSimConnect, 0, EVENT_RUDDER_SET, intParameter, \
									 SIMCONNECT_GROUP_PRIORITY_HIGHEST, SIMCONNECT_EVENT_FLAG_GROUPID_IS_PRIORITY);

							 }
							 //Если не на земле устанавливаем руль направления в нейтральное положение
							 else
							 {
								 SimConnect_TransmitClientEvent(hSimConnect, 0, EVENT_RUDDER_SET, 0, \
									 SIMCONNECT_GROUP_PRIORITY_HIGHEST, SIMCONNECT_EVENT_FLAG_GROUPID_IS_PRIORITY);

							 }
							 AddText("PaircraftData->FDPitch: " + PaircraftData->FDPitch + "\n");
							 AddText("PaircraftData->FDBank: " + PaircraftData->FDBank + "\n");
							 ////////////////////////////////////////////////////////
							 sTime = clock();
							 sHed = PaircraftData->hed;
							 sSpeed = PaircraftData->GS;

							 AddText("PaircraftData->VS: " + PaircraftData->VS + "\n");
							 AddText("ExportData.HorBar: " + ExportData.HorBar + "\n");
							 AddText("ExportData.HorEnabled: " + ExportData.HorEnabled + "\n");
							 Sleep(50);
							 break;
			}
			case ABORT_TAKE_OFF:
			{
								   break;
			}
			case CIRCLE_TAXI:
			{
								break;
			}

			case CLIMB:
			{
						  aircraftData* PaircraftData = &AircraftData;
						  hr = SimConnect_RequestDataOnSimObject(hSimConnect, REQ_AIRCRAFT_USER, DEF_AIRCRAFT_USER, SIMCONNECT_OBJECT_ID_USER, SIMCONNECT_PERIOD_ONCE);
						  AddText("CLIMB: " + "CLIMB" + "\n", true);

						  if (PaircraftData->AS > 230)
						  {
							  setNGXDataUChar(EVT_GEAR_LEVER, 1, &NGX.MAIN_GearLever);
							  if (NGX.MCP_Altitude > 5000)
							  {

								  //setNGXDataBool(EVT_MCP_LVL_CHG_SWITCH, TRUE, &NGX.MCP_annunLVL_CHG);
							  }
						  }
						  else if (PaircraftData->AS > 218)
						  {
							  if (NGX.MCP_Altitude > 5000)
							  {

								  //setNGXDataBool(EVT_MCP_LVL_CHG_SWITCH, TRUE, &NGX.MCP_annunLVL_CHG);
							  }
							  //setNGXDataFloat(EVT_MCP_SPEED_SELECTOR, 240, &NGX.MCP_IASMach);
							  SimConnect_TransmitClientEvent(hSimConnect, 0, EVENT_CONTROL_STAND_FLAPS_LEVER_0, MOUSE_FLAG_LEFTSINGLE, SIMCONNECT_GROUP_PRIORITY_HIGHEST, SIMCONNECT_EVENT_FLAG_GROUPID_IS_PRIORITY);

						  }
						  else if (PaircraftData->AS > 190)
						  {
							  SimConnect_TransmitClientEvent(hSimConnect, 0, EVENT_CONTROL_STAND_FLAPS_LEVER_1, MOUSE_FLAG_LEFTSINGLE, SIMCONNECT_GROUP_PRIORITY_HIGHEST, SIMCONNECT_EVENT_FLAG_GROUPID_IS_PRIORITY);
						  }
						  if ((PaircraftData->alt > 10000) && (PaircraftData->alt < 11000))
						  {
							  //setNGXDataFloat(EVT_MCP_SPEED_SELECTOR, 330, &NGX.MCP_IASMach);
						  }
						  if (PaircraftData->alt<10000)
						  {
							  setNGXDataBool(EVT_OH_LIGHTS_LOGO, TRUE, &NGX.LTS_LogoSw);
							  setNGXDataBool(EVT_OH_LIGHTS_TAXI, TRUE, &NGX.LTS_TaxiSw);
							  setNGXDataBool(EVT_OH_LIGHTS_ANT_COL, TRUE, &NGX.LTS_AntiCollisionSw);
							  setNGXDataBool(EVT_OH_LIGHTS_L_TURNOFF, FALSE, &NGX.LTS_RunwayTurnoffSw[0]);
							  setNGXDataBool(EVT_OH_LIGHTS_R_TURNOFF, FALSE, &NGX.LTS_RunwayTurnoffSw[1]);
							  setNGXDataUChar(EVT_OH_LIGHTS_POS_STROBE, 2, &NGX.LTS_PositionSw, TRUE);
							  setNGXDataUChar(EVT_OH_LIGHTS_L_RETRACT, 0, &NGX.LTS_LandingLtRetractableSw[0]);
							  setNGXDataUChar(EVT_OH_LIGHTS_R_RETRACT, 0, &NGX.LTS_LandingLtRetractableSw[1]);
							  setNGXDataBool(EVT_OH_LIGHTS_L_FIXED, FALSE, &NGX.LTS_LandingLtFixedSw[0]);
							  setNGXDataBool(EVT_OH_LIGHTS_R_FIXED, FALSE, &NGX.LTS_LandingLtFixedSw[1]);
						  }
						  else
						  {
							  setNGXDataBool(EVT_OH_LIGHTS_LOGO, FALSE, &NGX.LTS_LogoSw);
							  setNGXDataBool(EVT_OH_LIGHTS_TAXI, FALSE, &NGX.LTS_TaxiSw);
							  setNGXDataBool(EVT_OH_LIGHTS_ANT_COL, TRUE, &NGX.LTS_AntiCollisionSw);
							  setNGXDataBool(EVT_OH_LIGHTS_L_TURNOFF, FALSE, &NGX.LTS_RunwayTurnoffSw[0]);
							  setNGXDataBool(EVT_OH_LIGHTS_R_TURNOFF, FALSE, &NGX.LTS_RunwayTurnoffSw[1]);
							  setNGXDataUChar(EVT_OH_LIGHTS_POS_STROBE, 2, &NGX.LTS_PositionSw, TRUE);
							  setNGXDataUChar(EVT_OH_LIGHTS_L_RETRACT, 0, &NGX.LTS_LandingLtRetractableSw[0]);
							  setNGXDataUChar(EVT_OH_LIGHTS_R_RETRACT, 0, &NGX.LTS_LandingLtRetractableSw[1]);
							  setNGXDataBool(EVT_OH_LIGHTS_L_FIXED, FALSE, &NGX.LTS_LandingLtFixedSw[0]);
							  setNGXDataBool(EVT_OH_LIGHTS_R_FIXED, FALSE, &NGX.LTS_LandingLtFixedSw[1]);
						  }
						  if (PaircraftData->alt > 25000)
						  {
							  //setNGXDataFloat(EVT_MCP_SPEED_SELECTOR, 0.79, &NGX.MCP_IASMach);
						  }
						  if (!NGX.MCP_annunCMD_A)
						  {
							  if (ExportData.HorEnabled == 1)
							  {
								  ManPitchWithFD(-ExportData.HorBar, PaircraftData);
							  }
							  else
							  {
								  ManPitchWithFD(-10, PaircraftData);
							  }

							  if (ExportData.VerEnabled == 1)
							  {
								  ManBankWithFD(-ExportData.VerBar, PaircraftData);
							  }
							  else
							  {
								  ManBankWithFD(0, PaircraftData);
							  }



						  }
						  //AddText("ExportData.HorBar: " + ExportData.HorBar + "\n");
						  Sleep(50);
						  break;
			}
			case CRUISE:
			{
						   break;
			}
			case DESCENT:
			{
							break;
			}
			case LANDING:
			{
							break;
			}
			case ABORT_LANDING:
			{
								  break;
			}
			case BRAKE:
			{
						  break;
			}
			case TAXI_IN:
			{
							break;
			}
			case PARK:
			{
						 break;
			}
			case SHUTDOWN:
			{
							 break;
			}
			case SECURE:
			{
						   break;
			}

			default:
				break;
			}
			Sleep(10);
		}
		disconnectSafe();
	}

	void Disconnect()
	{

		hr = SimConnect_Close(hSimConnect);
		MyForm::mainForm->button1->Text = "Disconnected...";
		MyForm::mainForm->Refresh();
		MyForm::mainForm->textBox1->Clear();
		for (int currHeight = MyForm::mainForm->button1->Size.Height; currHeight < 237; currHeight++)
		{
			MyForm::mainForm->button1->Size = System::Drawing::Size(MyForm::mainForm->button1->Size.Width, currHeight);
			if (currHeight < 231)
			{
				MyForm::mainForm->textBox1->Size = System::Drawing::Size(MyForm::mainForm->textBox1->Size.Width, 231 - currHeight);
				MyForm::mainForm->textBox1->Location = System::Drawing::Point(MyForm::mainForm->textBox1->Location.X, 249 - (231 - currHeight));
			}
			MyForm::mainForm->Refresh();
			Sleep(1);
		}
		MyForm::mainForm->button1->ForeColor = System::Windows::Forms::Control::DefaultForeColor;
		MyForm::mainForm->button1->BackColor = System::Windows::Forms::Control::DefaultBackColor;
		MyForm::mainForm->button1->FlatAppearance->BorderColor = System::Drawing::Color::Blue;
		MyForm::mainForm->button1->Text = "Connect to the simulator.";
		MyForm::mainForm->Refresh();
		Connected = FALSE;

	}

	void Connect()
	{
		static int ii = 0;
		ii++;
		FillWays();
		MyForm::mainForm->SetControlSafe(L"label1", L"text", ii.ToString());
		MyForm::mainForm->SetControlSafe(L"label1", L"font", %Font(L"", 14));
		MyForm::mainForm->button1->ForeColor = System::Drawing::Color::DarkBlue;
		MyForm::mainForm->button1->BackColor = System::Drawing::Color::LightBlue;
		MyForm::mainForm->button1->FlatAppearance->BorderColor = System::Drawing::Color::DarkBlue;
		Thread ^loopThr;
		if (!Connected)
		{

			MyForm::mainForm->button1->Text = "Try connected...";
			MyForm::mainForm->Refresh();
			Sleep(500);
			if (SUCCEEDED(SimConnect_Open(&hSimConnect, "PMDG NGX Test", NULL, 0, 0, 0)))
			{
				for (int currHeight = MyForm::mainForm->button1->Size.Height; currHeight > 27; currHeight--)
				{
					MyForm::mainForm->button1->Size = System::Drawing::Size(MyForm::mainForm->button1->Size.Width, currHeight);
					if (currHeight < 231)
					{
						MyForm::mainForm->textBox1->Size = System::Drawing::Size(MyForm::mainForm->textBox1->Size.Width, 231 - currHeight);
						MyForm::mainForm->textBox1->Location = System::Drawing::Point(MyForm::mainForm->textBox1->Location.X, 249 - (231 - currHeight));
					}
					MyForm::mainForm->Refresh();
					Sleep(1);
				}
				MyForm::mainForm->button1->ForeColor = System::Drawing::Color::DarkGreen;
				MyForm::mainForm->button1->BackColor = System::Drawing::Color::LightGreen;
				MyForm::mainForm->button1->FlatAppearance->BorderColor = System::Drawing::Color::DarkGreen;
				MyForm::mainForm->button1->Text = "Connected to Flight Simulator!";
				MyForm::mainForm->Refresh();


				// 1) Set up data connection

				// Associate an ID with the PMDG data area name
				hr = SimConnect_MapClientDataNameToID(hSimConnect, PMDG_NGX_DATA_NAME, PMDG_NGX_DATA_ID);
				hr = SimConnect_MapClientDataNameToID(hSimConnect, PMDG_ADD_DATA_NAME, PMDG_ADD_DATA_ID);

				// Define the data area structure - this is a required step
				hr = SimConnect_AddToClientDataDefinition(hSimConnect, PMDG_NGX_DATA_DEFINITION, 0, sizeof(PMDG_NGX_Data), 0, 0);
				hr = SimConnect_AddToClientDataDefinition(hSimConnect, PMDG_ADD_DATA_DEFINITION, 0, sizeof(sExportData), 0, 0);

				// Sign up for notification of data change.  
				// SIMCONNECT_CLIENT_DATA_REQUEST_FLAG_CHANGED flag asks for the data to be sent only when some of the data is changed.
				hr = SimConnect_RequestClientData(hSimConnect, PMDG_NGX_DATA_ID, DATA_REQUEST, PMDG_NGX_DATA_DEFINITION,
					SIMCONNECT_CLIENT_DATA_PERIOD_ON_SET, SIMCONNECT_CLIENT_DATA_REQUEST_FLAG_CHANGED, 0, 0, 0);

				hr = SimConnect_RequestClientData(hSimConnect, PMDG_ADD_DATA_ID, ADD_DATA_REQUEST, PMDG_ADD_DATA_DEFINITION,
					SIMCONNECT_CLIENT_DATA_PERIOD_SECOND, SIMCONNECT_CLIENT_DATA_REQUEST_FLAG_CHANGED, 0, 0, 0);


				// 2) Set up control connection

				// First method: control data area
				PMDG_TEST::Control.Event = 0;
				PMDG_TEST::Control.Parameter = 0;

				// Associate an ID with the PMDG control area name
				hr = SimConnect_MapClientDataNameToID(hSimConnect, PMDG_NGX_CONTROL_NAME, PMDG_NGX_CONTROL_ID);


				// Define the control area structure - this is a required step
				hr = SimConnect_AddToClientDataDefinition(hSimConnect, PMDG_NGX_CONTROL_DEFINITION, 0, sizeof(PMDG_NGX_Control), 0, 0);

				// Sign up for notification of control change.  
				hr = SimConnect_RequestClientData(hSimConnect, PMDG_NGX_CONTROL_ID, CONTROL_REQUEST, PMDG_NGX_CONTROL_DEFINITION,
					SIMCONNECT_CLIENT_DATA_PERIOD_ON_SET, SIMCONNECT_CLIENT_DATA_REQUEST_FLAG_CHANGED, 0, 0, 0);

				// Second method: Create event IDs for controls that we are going to operate
				hr = SimConnect_MapClientEventToSimEvent(hSimConnect, EVENT_LOGO_LIGHT_SWITCH, "#69754");		//EVT_OH_LIGHTS_LOGO
				hr = SimConnect_MapClientEventToSimEvent(hSimConnect, EVENT_CONTROL_STAND_FLAPS_LEVER_0, "#76773");		//EVT_OH_LIGHTS_LOGO
				hr = SimConnect_MapClientEventToSimEvent(hSimConnect, EVENT_CONTROL_STAND_FLAPS_LEVER_1, "#76774");
				hr = SimConnect_MapClientEventToSimEvent(hSimConnect, EVENT_CONTROL_STAND_FLAPS_LEVER_5, "#76776");
				hr = SimConnect_MapClientEventToSimEvent(hSimConnect, EVENT_FLIGHT_DIRECTOR_SWITCH, "#70010");	//EVT_MCP_FD_SWITCH_L
				hr = SimConnect_MapClientEventToSimEvent(hSimConnect, EVENT_HEADING_SELECTOR, "#70022");		//EVT_MCP_HEADING_SELECTOR
				hr = SimConnect_MapClientEventToSimEvent(hSimConnect, EVENT_THROTTLE_SET, "THROTTLE_SET");
				hr = SimConnect_MapClientEventToSimEvent(hSimConnect, EVENT_RUDDER_SET, "RUDDER_SET");
				hr = SimConnect_MapClientEventToSimEvent(hSimConnect, EVENT_ELEVATOR_SET, "AXIS_ELEVATOR_SET");
				hr = SimConnect_MapClientEventToSimEvent(hSimConnect, EVENT_AILERON_SET, "AILERON_SET");
				hr = SimConnect_MapClientEventToSimEvent(hSimConnect, EVENT_TOGA, "AUTO_THROTTLE_TO_GA");


				//hr = SimConnect_MapClientEventToSimEvent(hSimConnect, EVENT_CONTROL_STAND_FLAPS_LEVER_5, "EVT_CONTROL_STAND_FLAPS_LEVER_5");


				// 3) Request current aircraft .air file path
				hr = SimConnect_RequestSystemState(hSimConnect, AIR_PATH_REQUEST, "AircraftLoaded");
				// also request notifications on sim start and aircraft change
				hr = SimConnect_SubscribeToSystemEvent(hSimConnect, EVENT_SIM_START, "SimStart");


				// 4) Assign keyboard shortcuts
				hr = SimConnect_MapClientEventToSimEvent(hSimConnect, EVENT_KEYBOARD_A);
				hr = SimConnect_MapClientEventToSimEvent(hSimConnect, EVENT_KEYBOARD_B);
				hr = SimConnect_MapClientEventToSimEvent(hSimConnect, EVENT_KEYBOARD_C);
				hr = SimConnect_MapClientEventToSimEvent(hSimConnect, EVENT_KEYBOARD_D);

				hr = SimConnect_AddClientEventToNotificationGroup(hSimConnect, GROUP_KEYBOARD, EVENT_KEYBOARD_A);
				hr = SimConnect_AddClientEventToNotificationGroup(hSimConnect, GROUP_KEYBOARD, EVENT_KEYBOARD_B);
				hr = SimConnect_AddClientEventToNotificationGroup(hSimConnect, GROUP_KEYBOARD, EVENT_KEYBOARD_C);
				hr = SimConnect_AddClientEventToNotificationGroup(hSimConnect, GROUP_KEYBOARD, EVENT_KEYBOARD_D);
				//hr = SimConnect_AddClientEventToNotificationGroup(hSimConnect, GROUP0, EVENT_THROTTLE_SET);

				hr = SimConnect_SetNotificationGroupPriority(hSimConnect, GROUP_KEYBOARD, SIMCONNECT_GROUP_PRIORITY_HIGHEST);
				hr = SimConnect_SetNotificationGroupPriority(hSimConnect, GROUP0, SIMCONNECT_GROUP_PRIORITY_HIGHEST);

				hr = SimConnect_MapInputEventToClientEvent(hSimConnect, INPUT0, "shift+ctrl+a", EVENT_KEYBOARD_A);
				hr = SimConnect_MapInputEventToClientEvent(hSimConnect, INPUT0, "shift+ctrl+b", EVENT_KEYBOARD_B);
				hr = SimConnect_MapInputEventToClientEvent(hSimConnect, INPUT0, "shift+ctrl+c", EVENT_KEYBOARD_C);
				hr = SimConnect_MapInputEventToClientEvent(hSimConnect, INPUT0, "shift+ctrl+d", EVENT_KEYBOARD_D);

				hr = SimConnect_SetInputGroupState(hSimConnect, INPUT0, SIMCONNECT_STATE_ON);

				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_AIRCRAFT_USER, "Title", NULL, SIMCONNECT_DATATYPE_STRING256);
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_AIRCRAFT_USER, "INDICATED ALTITUDE", "feet");
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_AIRCRAFT_USER, "Plane Longitude", "degrees");
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_AIRCRAFT_USER, "Plane Latitude", "degrees");
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_AIRCRAFT_USER, "PLANE HEADING DEGREES TRUE", "degrees");
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_AIRCRAFT_USER, "RUDDER PEDAL POSITION", "position");
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_AIRCRAFT_USER, "GENERAL ENG THROTTLE LEVER POSITION:1", "Percent");
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_AIRCRAFT_USER, "GENERAL ENG THROTTLE LEVER POSITION:2", "Percent");
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_AIRCRAFT_USER, "TURB ENG N1:1", "Percent");
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_AIRCRAFT_USER, "TURB ENG N1:2", "Percent");
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_AIRCRAFT_USER, "GROUND VELOCITY", "Knots");
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_AIRCRAFT_USER, "AIRSPEED INDICATED", "Knots");
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_AIRCRAFT_USER, "DELTA HEADING RATE", "degrees per second");
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_AIRCRAFT_USER, "SIM ON GROUND", "bool");
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_AIRCRAFT_USER, "VERTICAL SPEED", "Feet per second");
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_AIRCRAFT_USER, "PLANE PITCH DEGREES", "degrees");
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_AIRCRAFT_USER, "PLANE BANK DEGREES", "degrees");
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_AIRCRAFT_USER, "YOKE Y POSITION", "position"); //ELEVATOR POSITION
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_AIRCRAFT_USER, "YOKE X POSITION", "position"); //AILERON POSITION
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_AIRCRAFT_USER, "ELEVATOR TRIM POSITION", "degrees");
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_AIRCRAFT_USER, "AUTOPILOT TAKEOFF POWER ACTIVE", "bool");
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_AIRCRAFT_USER, "AUTOPILOT FLIGHT DIRECTOR ACTIVE", "bool");
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_AIRCRAFT_USER, "AUTOPILOT FLIGHT DIRECTOR PITCH", "Radians");
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_AIRCRAFT_USER, "AUTOPILOT FLIGHT DIRECTOR BANK", "Radians");




				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_THROTTLE, "GENERAL ENG THROTTLE LEVER POSITION:1", "Percent");
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_THROTTLE, "GENERAL ENG THROTTLE LEVER POSITION:2", "Percent");

				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_THRUST, "TURB ENG N1:1", "Percent");
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_THRUST, "TURB ENG N1:2", "Percent");

				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_SPEEDS, "GROUND VELOCITY", "Knots");
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_SPEEDS, "AIRSPEED INDICATED", "Knots");
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_SPEEDS, "SIM ON GROUND", "bool");
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_SPEEDS, "AUTOPILOT TAKEOFF POWER ACTIVE", "bool");

				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_ELEVATOR, "YOKE Y POSITION", "position"); //ELEVATOR POSITION
				hr = SimConnect_AddToDataDefinition(hSimConnect, DEF_AILERON, "YOKE X POSITION", "position"); //ELEVATOR POSITION

				//hr = SimConnect_MapClientEventToSimEvent(hSimConnect, EVENT_ELEVATOR_SET, "ELEVATOR_SET");
				hr = SimConnect_AddClientEventToNotificationGroup(hSimConnect, GROUP_ELEVATOR, EVENT_ELEVATOR_SET);
				hr = SimConnect_SetNotificationGroupPriority(hSimConnect, GROUP_ELEVATOR, SIMCONNECT_GROUP_PRIORITY_HIGHEST);
				//hr = SimConnect_RequestDataOnSimObject(hSimConnect, REQ_ELEVATOR, DEF_ELEVATOR, SIMCONNECT_OBJECT_ID_USER, SIMCONNECT_PERIOD_NEVER);



				//hr = SimConnect_RequestDataOnSimObject(hSimConnect, REQ_AIRCRAFT_USER, DEF_AIRCRAFT_USER, SIMCONNECT_OBJECT_ID_USER, SIMCONNECT_PERIOD_SECOND);
				hr = SimConnect_RequestDataOnSimObject(hSimConnect, REQ_THRUST, DEF_THRUST, SIMCONNECT_OBJECT_ID_USER, SIMCONNECT_PERIOD_SECOND);
				hr = SimConnect_RequestDataOnSimObject(hSimConnect, REQ_SPEEDS, DEF_SPEEDS, SIMCONNECT_OBJECT_ID_USER, SIMCONNECT_PERIOD_SECOND);

				quit = 0;
				//Sleep(10000);
				//mode = PREPARE;
				// 5) Main loop

				ThreadStart ^myThreadDelegate = gcnew ThreadStart(loopThrFunc);
				loopThr = gcnew Thread(myThreadDelegate);
				loopThr->IsBackground = TRUE;
				Connected = TRUE;
				loopThr->Start();

			}
			else
			{
				MyForm::mainForm->button1->ForeColor = System::Drawing::Color::DarkRed;
				MyForm::mainForm->button1->BackColor = System::Drawing::Color::LightPink;
				MyForm::mainForm->button1->FlatAppearance->BorderColor = System::Drawing::Color::DarkRed;
				MyForm::mainForm->button1->Text = "Unable to connect! Please verify the simulator`s run, and try again";

				//printf("\nUnable to connect!\n");
			}
		}
		else
		{

			quit = 1;
			//loopThr->Join();
			//disconnect();
		}
	};
}
*/








